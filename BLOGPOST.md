# Zed: The Next-Generation Code Editor for Collaboration with AI *and* Each Other

Zed, the brain child of the team behind Atom and Tree-sitter, is taking a different approach to disrupting the ever-competitive landscape of code editors. Instead of focusing solely on AI integration, Zed emphasizes collaboration and seamless teamwork whether that be with AI or with other developers, backed by performance to make every part of the coding experience feel natural. Three key features set Zed apart:

1. **AI Assistance**: Zed integrates advanced AI capabilities to provide intelligent code suggestions and error detection.
2. **Seamless Collaboration**: Zed supports real-time collaboration with other developers, enhancing productivity and teamwork.
3. **Blazing-Fast Performance**: Zed is built from scratch to ensure lightning-fast performance and responsiveness.

Zed was also open-sourced in 2024, giving it an edge against the prolific but closed-source GitHub Copilot and Cursor.

### Working with AI in Zed

The AI integration in Zed is designed to be both powerful and unobtrusive. Users can interact with AI through several interfaces:

1. **Assistant Panel**: A dedicated conversation interface for generating, transforming, and analyzing code
2. **Slash Commands**: Built-in commands to enhance prompts and improve AI responses
3. **Inline Assistant**: Direct code editing with AI within the editor interface
4. **Prompt Libraries**: Personalized collections of prompts for more efficient context-sharing with AI

### Working with Others in Zed

Zed's collaboration features extend beyond just real-time editing through its innovative "Channels" system. Channels function as virtual offices optimized for software teams, providing structured spaces for both active pair programming and passive awareness of ongoing work.

When joining a channel, developers can communicate over voice chat and have the option to collaborate remotely on shared Zed projects. Think of it like screensharing, but with the added benefit of allowing Google Docs-like collaboration on the code you're sharing.

## Technical Implementation: ML Integration and Architecture

The ML aspects of Zed are cleverly integrated into the overall architecture:

### Provider-Agnostic AI Architecture

Zed is designed to work with multiple AI providers through a flexible architecture:

- Support for OpenAI-compatible APIs
- Integration with self-hosted models through services like [Ollama](https://ollama.com/)
- Built-in open-source model [Zeta](https://zed.dev/blog/edit-prediction) fine-tuned by Zed for Zed

This provider-agnostic approach gives users flexibility in choosing which AI systems to use while still providing a great experience out-of-the-box.

### Prompting

Since Zed is open-source, we can take a look at how it handles prompting and what exactly it passes to the LLM when we use its features. The default prompt templates are designed to be flexible and are updated to use the latest features that Zed provides. Zed's [assets/prompts](https://github.com/zed-industries/zed/tree/main/assets/prompts) directory contains all five default prompt templates:

1. `assistant_system_prompt.hbs`: Used as the system prompt for the assistant.
2. `content_prompt.hbs`: Used for generating content in the editor.
3. `project_slash_command.hbs`: Used for generating search queries to retrieve relevant documents to a question about the codebase.
4. `suggest_edits.hbs`: Used for generating suggested edits. Ensures that the edits are returned in an XML format.
5. `terminal_assistant_prompt.hbs`: Used for generating terminal commands.

Double curly brackets are used to denote placeholders in the templates. For example, {{variable}} will be replaced with the value of the variable when the template is rendered. This connects the non-ML components of Zed (the UI and files) with the ML component (LLMs).

One other thing to mention is the use of embeddings to improve the accuracy of the search queries generated by the `project_slash_command.hbs` template. Embeddings are dense vectors that represent the meaning of a word or phrase in a high-dimensional space. By using embeddings, Zed can more accurately match search queries to relevant documents, even if the query is phrased differently than the document. This is another example of intelligently integrating ML into the non-ML components of Zed for a better user experience.

Of course, all of these templates are overridable. Users can customize them to fit their specific needs but this is not recommended as this could accidentally lead to missing out on new features added in future updates.

### Core Architecture

Outside of ML, Zed boasts innovative architectural features that lead to its performance and functionality.

1. **GPUI Framework**: Central to Zed's performance is GPUI, a custom hardware-accelerated UI framework which directly leverages the GPU to render the editor interface. This eliminates layers of abstraction that add overhead, directly undercutting other editors that rely on slower frameworks such as Electron or Qt.
2. **Language Processing**: Zed employs advanced language processing techniques to enhance its usability. This includes the use of Tree-sitter for syntax highlighting and code structure comprehension, as well as the Language Server Protocol (LSP) for intelligent code features like autocomplete and error detection.

## Engineering Decisions and Design Choices

### Performance-First Philosophy

By writing the editor from scratch in Rust and heavily relying on GPU acceleration, the team prioritized performance above all. No video or testimony will do justice to the raw feeling of responsiveness that comes with using Zed. Much like how I found Eclipse hard to use after trying VS Code, I now find using VS Code to be painfully slow given the existence of Zed.

### Human-AI Interaction Design

Zed's approach to AI integration shows careful consideration:

- AI is accessible but not intrusive
- Multiple interaction modes (conversation, inline editing, commands)
- Support for user-created prompt libraries for greater customization
- Recent addition of tracking for LLM-generated commit messages, showing awareness of attribution and transparency

### Collaboration

The focus on collaboration reflects the founders' vision for more fluid team interactions. As co-founder Max described in an [interview](https://zed.dev/blog/full-spectrum-of-collaboration):

> I realize, "wait a minute, I have a deeper question about this. I need to talk to you." I say, "hey, can you talk?" and then, beep boop, you're in my editor, we're talking, we're pairing.

This level of collaboration built-in to the editor removes the need for "pull requests and Slack and screen sharing" which Max describes as the "trifecta of today's collaboration tools."

Though I find the concept incredibly exciting, requiring all developers on a team to use the same editor is likely a hard ask and might pose a barrier to adoption.

## Development Process and Community

### Open Source Strategy

The decision to open-source Zed came after initial development and reflects strategic thinking. As Sobo [explained](https://www.infoq.com/news/2024/02/zed-code-editor-open-sourced/):

> We believe that making Zed open source will make it the best product. Our mission is to build the world's most advanced code editor and get it into the hands of millions of developers. There's a ton of surface area on that problem, and we'll need all the help we can get.

### Robust Testing and CI/CD

The project's GitHub repository shows an extensive [continuous integration workflow](https://github.com/zed-industries/zed/actions) running tests across multiple platforms (macOS, Linux, Windows soon), checking code formatting, and performing various static analyses. This comprehensive approach helps maintain code quality as the project grows.

## Zed in Action

To demonstrate Zed's capabilities, let's create a simple static webpage and add it to my blog [tylerho.dev](https://tylerho.dev).

First, I asked the assistant to generate a svelte file that is able to display the content in the markdown file. Adding all these files was a simple `/tab` given that I had all the context tabs already open.

![assistant](https://github.com/Tyrest/Zed-Tutorial/blob/master/images/Assistant.png?raw=true)

Once the assistant generated the file, I simply asked it to apply the changes since the in-line assistant has access to all the context from the dedicated chat window.

![apply](https://github.com/Tyrest/Zed-Tutorial/blob/master/images/Apply.png?raw=true)

Since it added a few features that I didn't need, I deleted some of the unnecessary parts but then realized that the subtitle was not as catchy as I had hoped. Since I'm not a subtitle-writing expert, I decided to call my alter-ego Tyler-Ho-Dev to help me come up with a better one. Giving him access to the file was as simple as calling him on Zed and sharing my screen. His changes were not only instantly applied in my editor as can be seen in the screenshot below, but also reflected in the live preview of the webpage on my local machine.

![collaboration](https://github.com/Tyrest/Zed-Tutorial/blob/master/images/Collaboration.png?raw=true)

This blog post is cross-posted using the code generated above [here](https://tylerho.dev/projects/zed).

The whole process was seamless and efficient, keeping the power in my hands at all times but also allowing me to pull from the expertise of bleeding-edge LLMs and fellow developers.

## Conclusion

Zed represents a fascinating example of how AI is being integrated into developer workflows. By building a code editor that treats performance, AI assistance, and collaboration as equally important, the Zed team is reimagining what development tools can be in an era of AI-assisted programming.

As the boundaries between human and AI coding continue to blur, tools like Zed will play an increasingly important role in shaping how we think about the programming experience. Whether Zed itself becomes the dominant editor of the future or simply influences the next generation of development tools, the lessons from its design and implementation will be valuable for anyone interested in the intersection of software engineering and machine learning.
